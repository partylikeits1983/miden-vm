use alloc::{
    boxed::Box,
    collections::{VecDeque, BTreeSet},
    string::ToString,
    sync::Arc,
    vec::Vec,
};
use core::{marker::PhantomData, num::NonZeroU32};

use smallvec::smallvec;
use vm_core::{Felt, FieldElement, StarkField, crypto::hash::RpoDigest};

use crate::{LibraryPath, LibraryNamespace, ProcedureName, ast::*, diagnostics::SourceFile};
use super::{
    HexEncodedValue, Token, ParseError, ParsingError,
    LiteralErrorKind, HexErrorKind, Span, Spanned,
    DocumentationType
};

grammar<'input>(
    source_file: &Arc<SourceFile>,
    interned: &mut BTreeSet<Arc<str>>,
    _marker: PhantomData<&'input str>
);

// LEXER
// ================================================================================================

extern {
    type Error = ParsingError;
    type Location = u32;

    enum Token<'input> {
        bare_ident => Token::Ident(<&'input str>),
        const_ident => Token::ConstantIdent(<&'input str>),
        quoted_ident => Token::QuotedIdent(<&'input str>),
        hex_value => Token::HexValue(<HexEncodedValue>),
        doc_comment => Token::DocComment(<DocumentationType>),
        uint => Token::Int(<u64>),
        "add" => Token::Add,
        "adv.insert_hdword" => Token::AdvInsertHdword,
        "adv.insert_hperm" => Token::AdvInsertHperm,
        "adv.insert_mem" => Token::AdvInsertMem,
        "adv_loadw" => Token::AdvLoadw,
        "adv_pipe" => Token::AdvPipe,
        "adv_push" => Token::AdvPush,
        "adv.push_ext2intt" => Token::AdvPushExt2intt,
        "adv.push_mapval" => Token::AdvPushMapval,
        "adv.push_mapvaln" => Token::AdvPushMapvaln,
        "adv.push_mtnode" => Token::AdvPushMtnode,
        "adv.push_sig" => Token::AdvPushSig,
        "adv.push_smtpeek" => Token::AdvPushSmtpeek,
        "adv.push_smtget" => Token::AdvPushSmtget,
        "adv.push_smtset" => Token::AdvPushSmtset,
        "adv.push_u64div" => Token::AdvPushU64Div,
        "and" => Token::And,
        "assert" => Token::Assert,
        "assertz" => Token::Assertz,
        "assert_eq" => Token::AssertEq,
        "assert_eqw" => Token::AssertEqw,
        "begin" => Token::Begin,
        "caller" => Token::Caller,
        "call" => Token::Call,
        "cdrop" => Token::Cdrop,
        "cdropw" => Token::Cdropw,
        "clk" => Token::Clk,
        "const" => Token::Const,
        "cswap" => Token::Cswap,
        "cswapw" => Token::Cswapw,
        "debug" => Token::Debug,
        "div" => Token::Div,
        "drop" => Token::Drop,
        "dropw" => Token::Dropw,
        "dup" => Token::Dup,
        "dupw" => Token::Dupw,
        "dynexec" => Token::Dynexec,
        "dyncall" => Token::Dyncall,
        "else" => Token::Else,
        "emit" => Token::Emit,
        "end" => Token::End,
        "eq" => Token::Eq,
        "eqw" => Token::Eqw,
        "ext2add" => Token::Ext2Add,
        "ext2div" => Token::Ext2Div,
        "ext2inv" => Token::Ext2Inv,
        "ext2mul" => Token::Ext2Mul,
        "ext2neg" => Token::Ext2Neg,
        "ext2sub" => Token::Ext2Sub,
        "err" => Token::Err,
        "exec" => Token::Exec,
        "exp" => Token::Exp,
        "exp.u" => Token::ExpU,
        "export" => Token::Export,
        "fri_ext2fold4" => Token::FriExt2Fold4,
        "gt" => Token::Gt,
        "gte" => Token::Gte,
        "hash" => Token::Hash,
        "hperm" => Token::Hperm,
        "hmerge" => Token::Hmerge,
        "if.true" => Token::If,
        "ilog2" => Token::ILog2,
        "inv" => Token::Inv,
        "is_odd" => Token::IsOdd,
        "local" => Token::Local,
        "locaddr" => Token::Locaddr,
        "loc_load" => Token::LocLoad,
        "loc_loadw" => Token::LocLoadw,
        "loc_store" => Token::LocStore,
        "loc_storew" => Token::LocStorew,
        "lt" => Token::Lt,
        "lte" => Token::Lte,
        "mem" => Token::Mem,
        "mem_load" => Token::MemLoad,
        "mem_loadw" => Token::MemLoadw,
        "mem_store" => Token::MemStore,
        "mem_storew" => Token::MemStorew,
        "mem_stream" => Token::MemStream,
        "movdn" => Token::Movdn,
        "movdnw" => Token::Movdnw,
        "movup" => Token::Movup,
        "movupw" => Token::Movupw,
        "mtree_get" => Token::MtreeGet,
        "mtree_merge" => Token::MtreeMerge,
        "mtree_set" => Token::MtreeSet,
        "mtree_verify" => Token::MtreeVerify,
        "mul" => Token::Mul,
        "neg" => Token::Neg,
        "neq" => Token::Neq,
        "not" => Token::Not,
        "or" => Token::Or,
        "padw" => Token::Padw,
        "pow2" => Token::Pow2,
        "proc" => Token::Proc,
        "procref" => Token::Procref,
        "push" => Token::Push,
        "rcomb_base" => Token::RCombBase,
        "repeat" => Token::Repeat,
        "rpo_falcon512" => Token::RpoFalcon512,
        "sdepth" => Token::Sdepth,
        "stack" => Token::Stack,
        "sub" => Token::Sub,
        "swap" => Token::Swap,
        "swapw" => Token::Swapw,
        "swapdw" => Token::Swapdw,
        "syscall" => Token::Syscall,
        "trace" => Token::Trace,
        "use" => Token::Use,
        "u32and" => Token::U32And,
        "u32assert" => Token::U32Assert,
        "u32assert2" => Token::U32Assert2,
        "u32assertw" => Token::U32Assertw,
        "u32cast" => Token::U32Cast,
        "u32div" => Token::U32Div,
        "u32divmod" => Token::U32Divmod,
        "u32gt" => Token::U32Gt,
        "u32gte" => Token::U32Gte,
        "u32lt" => Token::U32Lt,
        "u32lte" => Token::U32Lte,
        "u32max" => Token::U32Max,
        "u32min" => Token::U32Min,
        "u32mod" => Token::U32Mod,
        "u32not" => Token::U32Not,
        "u32or" => Token::U32Or,
        "u32overflowing_add" => Token::U32OverflowingAdd,
        "u32overflowing_add3" => Token::U32OverflowingAdd3,
        "u32overflowing_madd" => Token::U32OverflowingMadd,
        "u32overflowing_mul" => Token::U32OverflowingMul,
        "u32overflowing_sub" => Token::U32OverflowingSub,
        "u32popcnt" => Token::U32Popcnt,
        "u32clz" => Token::U32Clz,
        "u32ctz" => Token::U32Ctz,
        "u32clo" => Token::U32Clo,
        "u32cto" => Token::U32Cto,
        "u32rotl" => Token::U32Rotl,
        "u32rotr" => Token::U32Rotr,
        "u32shl" => Token::U32Shl,
        "u32shr" => Token::U32Shr,
        "u32split" => Token::U32Split,
        "u32test" => Token::U32Test,
        "u32testw" => Token::U32Testw,
        "u32wrapping_add" => Token::U32WrappingAdd,
        "u32wrapping_add3" => Token::U32WrappingAdd3,
        "u32wrapping_madd" => Token::U32WrappingMadd,
        "u32wrapping_mul" => Token::U32WrappingMul,
        "u32wrapping_sub" => Token::U32WrappingSub,
        "u32xor" => Token::U32Xor,
        "while.true" => Token::While,
        "xor" => Token::Xor,
        "!" => Token::Bang,
        "::" => Token::ColonColon,
        "." => Token::Dot,
        "=" => Token::Equal,
        "(" => Token::Lparen,
        "-" => Token::Minus,
        "+" => Token::Plus,
        "//" => Token::SlashSlash,
        "/" => Token::Slash,
        "*" => Token::Star,
        ")" => Token::Rparen,
        "->" => Token::Rstab,
        EOF => Token::Eof,
    }
}

// dot-delimited with at least one element
#[inline]
DotDelimited<T>: Vec<T> = {
    <mut v:(<T> ".")*> <e:T> => {
        v.push(e);
        v
    }
};


// ::-delimited with at least one element, no trailing delimiter
#[inline]
PathComponents<T>: Vec<T> = {
    <mut v:(<T> "::")*> <e:T> => {
        v.push(e);
        v
    }
};

// TOP-LEVEL FORMS
// ================================================================================================

pub Forms: Vec<Form> = {
    <forms:Form+> EOF => forms,
}

Form: Form = {
    Doc,
    Import,
    Const,
    Begin,
    Proc,
}

Doc: Form = {
    <l:@L> <doc:doc_comment> <r:@R> =>? {
        if doc.as_bytes().len() > u16::MAX as usize {
            Err(ParseError::User { error: ParsingError::DocsTooLarge { span: span!(l, r) } })
        } else {
            match doc {
                DocumentationType::Module(doc) => Ok(Form::ModuleDoc(Span::new(span!(l, r), doc))),
                DocumentationType::Form(doc) => Ok(Form::Doc(Span::new(span!(l, r), doc))),
            }
        }
    }
}

Import: Form = {
    <l:@L> "use" "." <import_path:MaybeQualifiedName> <alias:("->" <BareIdent>)?> <r:@R> =>? {
        match import_path {
            (module_name, None) => Err(ParseError::User {
                error: ParsingError::UnqualifiedImport { span: span!(l, r) },
            }),
            (module_name, Some(path)) => {
                let path = path.append_ident(module_name.clone())
                    .map_err(|error| {
                        ParseError::User { error: ParsingError::InvalidLibraryPath { span: span!(l, r), message: error.to_string() }}
                    })?;
                let name = alias.unwrap_or(module_name);
                Ok(Form::Import(Import { span: span!(l, r), name, path, uses: 0 }))
            }
        }
    }
}

Const: Form = {
    <l:@L> "const" "." <name:ConstantName> "=" <value:ConstantExpr> <r:@R> => {
        Form::Constant(Constant::new(
            span!(l, r),
            name,
            value,
        ))
    }
}

Begin: Form = {
    <l:@L> "begin" <body:Ops> "end" <r:@R> => {
        Form::Begin(Block::new(span!(l, r), body))
    }
}

Proc: Form = {
    <l:@L> <visibility:Visibility> "." <name:ProcedureName> <num_locals:MaybeParam<U16>> <body:Block> "end" <r:@R> =>? {
        let num_locals = num_locals.unwrap_or(0);
        let procedure = Procedure::new(
            span!(l, r),
            visibility,
            name,
            num_locals,
            body
        ).with_source_file(Some(source_file.clone()));
        Ok(Form::Procedure(Export::Procedure(procedure)))
    },

    <l:@L> "export" "." <qualified_name:QualifiedName> <alias:("->" <BareIdent>)?> <r:@R> => {
        let (name, path) = qualified_name;
        let name = ProcedureName::new_unchecked(name.clone());
        let export_name = alias.map(ProcedureName::new_unchecked).unwrap_or_else(|| name.clone());
        let target = FullyQualifiedProcedureName {
            span: span!(l, r),
            module: path,
            name,
        };
        let alias = ProcedureAlias::new(export_name, target)
                        .with_source_file(Some(source_file.clone()));
        Form::Procedure(Export::Alias(alias))
    }
}

#[inline]
Visibility: Visibility = {
    "proc" => Visibility::Private,
    "export" => Visibility::Public,
}

// CODE BLOCKS
// ================================================================================================

Block: Block = {
    <l:@L> <body:Ops> <r:@R> => Block::new(span!(l, r), body),
}

#[inline]
Ops: Vec<Op> = {
    <l:@L> <ops:Op+> <r:@R> =>? {
        let ops = ops.into_iter().flat_map(|ops| ops.into_iter()).collect::<Vec<_>>();
        if ops.len() > u16::MAX as usize {
            Err(ParseError::User { error: ParsingError::CodeBlockTooBig { span: span!(l, r) } })
        } else {
            Ok(ops)
        }
    },
}

Op: SmallOpsVec = {
    <IfElse> => smallvec![<>],
    <While> => smallvec![<>],
    <Repeat> => smallvec![<>],
    Instruction,
}

IfElse: Op = {
    <l:@L> "if.true" <then_blk:Block> "else" <else_blk:Block> "end" <r:@R> => {
        Op::If { span: span!(l, r), then_blk, else_blk }
    },

    <l:@L> "if.true" <then_blk:Block> "end" <r:@R> => {
        Op::If { span: span!(l, r), then_blk, else_blk: Default::default() }
    }
}

While: Op = {
    <l:@L> "while.true" <body:Block> "end" <r:@R> => {
        Op::While { span: span!(l, r), body }
    }
}

Repeat: Op = {
    <l:@L> "repeat" "." <count:uint> <body:Block> "end" <r:@R> =>? {
        let span = span!(l, r);
        u32::try_from(count)
            .map_err(|error| ParseError::User { error: ParsingError::ImmediateOutOfRange { span, range: 1..(u32::MAX as usize) } })
            .and_then(|count| {
                NonZeroU32::try_from(count)
                    .map(|count| Op::Repeat { span, count: count.get(), body })
                    .map_err(|error| ParseError::User { error: ParsingError::ImmediateOutOfRange { span, range: 1..(u32::MAX as usize) } })
            })
    }
}

#[inline]
Instruction: SmallOpsVec = {
    <l:@L> <inst:Inst> <r:@R> => smallvec![Op::Inst(Span::new(span!(l, r), inst))],
    // For instructions which may fold to zero or multiple instructions;
    // or for instruction macros, which expand to multiple instructions,
    // this is the rule under which those instructions should be handled
    MacroInst,
}

// INSTRUCTIONS
// ================================================================================================

MacroInst: SmallOpsVec = {
    // This rule is here because we constant-fold some operations
    FoldableInstWithFeltImmediate,
    FoldableInstWithU32Immediate,
    Push,
}

#[inline]
Inst: Instruction = {
    AdviceInjector,
    Assert,
    Call,
    Debug,
    InstWithU32Immediate,
    InstWithBitSizeImmediate,
    InstWithLocalIndex,
    InstWithStackIndex,
    ProcRef,
    "adv_pipe" => Instruction::AdvPipe,
    "adv_loadw" => Instruction::AdvLoadW,
    "and" => Instruction::And,
    "caller" => Instruction::Caller,
    "cdrop" => Instruction::CDrop,
    "cdropw" => Instruction::CDropW,
    "clk" => Instruction::Clk,
    "cswap" => Instruction::CSwap,
    "cswapw" => Instruction::CSwapW,
    "drop" => Instruction::Drop,
    "dropw" => Instruction::DropW,
    "dyncall" => Instruction::DynCall,
    "dynexec" => Instruction::DynExec,
    "eqw" => Instruction::Eqw,
    "ext2add" => Instruction::Ext2Add,
    "ext2div" => Instruction::Ext2Div,
    "ext2inv" => Instruction::Ext2Inv,
    "ext2mul" => Instruction::Ext2Mul,
    "ext2neg" => Instruction::Ext2Neg,
    "ext2sub" => Instruction::Ext2Sub,
    "fri_ext2fold4" => Instruction::FriExt2Fold4,
    "gt" => Instruction::Gt,
    "gte" => Instruction::Gte,
    "hash" => Instruction::Hash,
    "hperm" => Instruction::HPerm,
    "hmerge" => Instruction::HMerge,
    "ilog2" => Instruction::ILog2,
    "inv" => Instruction::Inv,
    "is_odd" => Instruction::IsOdd,
    "lt" => Instruction::Lt,
    "lte" => Instruction::Lte,
    "mem_stream" => Instruction::MemStream,
    "mtree_get" => Instruction::MTreeGet,
    "mtree_merge" => Instruction::MTreeMerge,
    "mtree_set" => Instruction::MTreeSet,
    "mtree_verify" => Instruction::MTreeVerify,
    "neg" => Instruction::Neg,
    "not" => Instruction::Not,
    "or" => Instruction::Or,
    "padw" => Instruction::PadW,
    "pow2" => Instruction::Pow2,
    "rcomb_base" => Instruction::RCombBase,
    "sdepth" => Instruction::Sdepth,
    "swapdw" => Instruction::SwapDw,
    "u32and" => Instruction::U32And,
    "u32cast" => Instruction::U32Cast,
    "u32gt" => Instruction::U32Gt,
    "u32gte" => Instruction::U32Gte,
    "u32lt" => Instruction::U32Lt,
    "u32lte" => Instruction::U32Lte,
    "u32max" => Instruction::U32Max,
    "u32min" => Instruction::U32Min,
    "u32not" => Instruction::U32Not,
    "u32or" => Instruction::U32Or,
    "u32overflowing_add3" => Instruction::U32OverflowingAdd3,
    "u32overflowing_madd" => Instruction::U32OverflowingMadd,
    "u32popcnt" => Instruction::U32Popcnt,
    "u32clz" => Instruction::U32Clz,
    "u32ctz" => Instruction::U32Ctz,
    "u32clo" => Instruction::U32Clo,
    "u32cto" => Instruction::U32Cto,
    "u32split" => Instruction::U32Split,
    "u32test" => Instruction::U32Test,
    "u32testw" => Instruction::U32TestW,
    "u32wrapping_add3" => Instruction::U32WrappingAdd3,
    "u32wrapping_madd" => Instruction::U32WrappingMadd,
    "u32xor" => Instruction::U32Xor,
    "xor" => Instruction::Xor,
}

#[inline]
AdviceInjector: Instruction = {
    "adv.insert_hdword" <domain:MaybeImm<U8>> => {
        domain.map(|domain| Instruction::AdvInject(AdviceInjectorNode::InsertHdwordImm { domain }))
              .unwrap_or(Instruction::AdvInject(AdviceInjectorNode::InsertHdword))
    },
    "adv.insert_hperm" => Instruction::AdvInject(AdviceInjectorNode::InsertHperm),
    "adv.insert_mem" => Instruction::AdvInject(AdviceInjectorNode::InsertMem),
    "adv.push_ext2intt" => Instruction::AdvInject(AdviceInjectorNode::PushExt2intt),
    "adv.push_mapval" <i:MaybeImm<StackWordOffset>> => {
        i.map(|offset| Instruction::AdvInject(AdviceInjectorNode::PushMapValImm { offset }))
         .unwrap_or(Instruction::AdvInject(AdviceInjectorNode::PushMapVal))
    },
    "adv.push_mapvaln" <i:MaybeImm<StackWordOffset>> => {
        i.map(|offset| Instruction::AdvInject(AdviceInjectorNode::PushMapValNImm { offset }))
         .unwrap_or(Instruction::AdvInject(AdviceInjectorNode::PushMapValN))
    },
    "adv.push_mtnode" => Instruction::AdvInject(AdviceInjectorNode::PushMtNode),
    "adv.push_sig" "." <kind:SignatureKind> => Instruction::AdvInject(AdviceInjectorNode::PushSignature { kind }),
    "adv.push_smtpeek" => Instruction::AdvInject(AdviceInjectorNode::PushSmtPeek),
    "adv.push_smtget" => Instruction::AdvInject(AdviceInjectorNode::PushSmtGet),
    "adv.push_smtset" => Instruction::AdvInject(AdviceInjectorNode::PushSmtSet),
    "adv.push_u64div" => Instruction::AdvInject(AdviceInjectorNode::PushU64Div),
}

#[inline]
Assert: Instruction = {
    "assert" <error_code:MaybeAssertCode> => error_code.map(Instruction::AssertWithError).unwrap_or(Instruction::Assert),
    "assertz" <error_code:MaybeAssertCode> => error_code.map(Instruction::AssertzWithError).unwrap_or(Instruction::Assertz),
    "assert_eq" <error_code:MaybeAssertCode> => error_code.map(Instruction::AssertEqWithError).unwrap_or(Instruction::AssertEq),
    "assert_eqw" <error_code:MaybeAssertCode> => error_code.map(Instruction::AssertEqwWithError).unwrap_or(Instruction::AssertEqw),
    "u32assert" <error_code:MaybeAssertCode> => error_code.map(Instruction::U32AssertWithError).unwrap_or(Instruction::U32Assert),
    "u32assert2" <error_code:MaybeAssertCode> => error_code.map(Instruction::U32Assert2WithError).unwrap_or(Instruction::U32Assert2),
    "u32assertw" <error_code:MaybeAssertCode> => error_code.map(Instruction::U32AssertWWithError).unwrap_or(Instruction::U32AssertW),
}

MaybeAssertCode: Option<Immediate<u32>> = {
    "." "err" "=" <code:ImmValue<U32>> => Some(code),
    => None,
}

Call: Instruction = {
    "exec" "." <callee:Callee> => Instruction::Exec(callee),
    "call" "." <callee:Callee> => Instruction::Call(callee),
    "syscall" "." <callee:Callee> => Instruction::SysCall(callee),
}

Callee: InvocationTarget = {
    <MastRoot> => InvocationTarget::MastRoot(<>),
    <module_name:(<BareIdent> "::")?> <name:BareProcedureName> => {
        match module_name {
            Some(module) => InvocationTarget::ProcedurePath { name, module },
            None => InvocationTarget::ProcedureName(name),
        }
    },
    <QuotedProcedureName> => InvocationTarget::ProcedureName(<>),
}

#[inline]
Debug: Instruction = {
    "debug" "." "stack" <n:MaybeImm<U16>> => {
        match n {
            Some(n) => Instruction::Debug(DebugOptions::StackTop(n)),
            None => Instruction::Debug(DebugOptions::StackAll),
        }
    },
    "debug" "." "mem" <n:Imm<U32>> <m:Imm<U32>> => Instruction::Debug(DebugOptions::MemInterval(n, m)),
    "debug" "." "mem" <n:MaybeImm<U32>> => {
        match n {
            Some(n) => Instruction::Debug(DebugOptions::MemInterval(n.clone(), n)),
            None => Instruction::Debug(DebugOptions::MemAll),
        }
    },
    "debug" "." "local" <n:Imm<U16>> <m:Imm<U16>> => Instruction::Debug(DebugOptions::LocalInterval(n, m)),
    "debug" "." "local" <n:MaybeImm<U16>> => {
        match n {
            Some(n) => Instruction::Debug(DebugOptions::LocalInterval(n.clone(), n)),
            None => Instruction::Debug(DebugOptions::LocalAll),
        }
    },
    "emit" "." <id:Imm<U32>> => Instruction::Emit(id),
    "trace" "." <id:Imm<U32>> => Instruction::Trace(id),
}

#[inline]
ProcRef: Instruction = {
    "procref" "." <l:@L> <target:MaybeQualifiedName> <r:@R> => {
        match target {
            (name, None) => {
                let name = ProcedureName::new_unchecked(name);
                Instruction::ProcRef(InvocationTarget::ProcedureName(name))
            },
            (name, Some(module)) => {
                let module = match module.namespace() {
                    LibraryNamespace::User(ns) => Ident::new_unchecked(Span::new(span!(l, r), ns.clone())),
                    _ => unreachable!(),
                };
                Instruction::ProcRef(InvocationTarget::ProcedurePath {
                    name: ProcedureName::new_unchecked(name),
                    module,
                })
            }
        }
    }
}

#[inline]
FoldableInstWithFeltImmediate: SmallOpsVec = {
    <l:@L> "eq" <imm:MaybeImm<Felt>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::EqImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::Eq))],
        }
    },
    <l:@L> "neq" <imm:MaybeImm<Felt>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::NeqImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::Neq))],
        }
    },
    <l:@L> "add" <imm:MaybeImm<Felt>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == Felt::ZERO => smallvec![],
            Some(imm) if imm == Felt::ONE => smallvec![Op::Inst(Span::new(span, Instruction::Incr))],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::AddImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::Add))],
        }
    },
    <l:@L> "sub" <imm:MaybeImm<Felt>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == Felt::ZERO => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::SubImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::Sub))],
        }
    },
    <l:@L> "mul" <imm:MaybeImm<Felt>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == Felt::ZERO => smallvec![Op::Inst(Span::new(span, Instruction::Drop)), Op::Inst(Span::new(span, Instruction::PushU8(0)))],
            Some(imm) if imm == Felt::ONE => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::MulImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::Mul))],
        }
    },
    <l:@L> "div" <imm:MaybeImm<Felt>> <r:@R> =>? {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == Felt::ZERO => Err(ParseError::User { error: ParsingError::DivisionByZero { span: span!(l, r) } }),
            Some(imm) if imm == Felt::ONE => Ok(smallvec![]),
            Some(imm) => Ok(smallvec![Op::Inst(Span::new(span, Instruction::DivImm(imm)))]),
            None => Ok(smallvec![Op::Inst(Span::new(span, Instruction::Div))]),
        }
    }
}

#[inline]
FoldableInstWithU32Immediate: SmallOpsVec = {
    <l:@L> "u32div" <imm:MaybeImm<U32>> <r:@R> =>? {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => Err(ParseError::User { error: ParsingError::DivisionByZero { span: span!(l, r) } }),
            Some(imm) if imm == 1 => Ok(smallvec![]),
            Some(imm) => Ok(smallvec![Op::Inst(Span::new(span, Instruction::U32DivImm(imm)))]),
            None => Ok(smallvec![Op::Inst(Span::new(span, Instruction::U32Div))]),
        }
    },
    <l:@L> "u32divmod" <imm:MaybeImm<U32>> <r:@R> =>? {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => Err(ParseError::User { error: ParsingError::DivisionByZero { span: span!(l, r) } }),
            Some(imm) => Ok(smallvec![Op::Inst(Span::new(span, Instruction::U32DivModImm(imm)))]),
            None => Ok(smallvec![Op::Inst(Span::new(span, Instruction::U32DivMod))]),
        }
    },
    <l:@L> "u32mod" <imm:MaybeImm<U32>> <r:@R> =>? {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => Err(ParseError::User { error: ParsingError::DivisionByZero { span: span!(l, r) } }),
            Some(imm) => Ok(smallvec![Op::Inst(Span::new(span, Instruction::U32ModImm(imm)))]),
            None => Ok(smallvec![Op::Inst(Span::new(span, Instruction::U32Mod))]),
        }
    },
    <l:@L> "u32wrapping_add" <imm:MaybeImm<U32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32WrappingAddImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32WrappingAdd))],
        }
    },
    <l:@L> "u32wrapping_sub" <imm:MaybeImm<U32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32WrappingSubImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32WrappingSub))],
        }
    },
    <l:@L> "u32wrapping_mul" <imm:MaybeImm<U32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![Op::Inst(Span::new(span, Instruction::Drop)), Op::Inst(Span::new(span, Instruction::PushU8(0)))],
            Some(imm) if imm == 1 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32WrappingMulImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32WrappingMul))],
        }
    },
    <l:@L> "u32overflowing_add" <imm:MaybeImm<U32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32OverflowingAddImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32OverflowingAdd))],
        }
    },
    <l:@L> "u32overflowing_sub" <imm:MaybeImm<U32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32OverflowingSubImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32OverflowingSub))],
        }
    },
    <l:@L> "u32overflowing_mul" <imm:MaybeImm<U32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![Op::Inst(Span::new(span, Instruction::Drop)), Op::Inst(Span::new(span, Instruction::PushU8(0)))],
            Some(imm) if imm == 1 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32OverflowingMulImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32OverflowingMul))],
        }
    },
    <l:@L> "u32shl" <imm:MaybeImm<Shift32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32ShlImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32Shl))],
        }
    },
    <l:@L> "u32shr" <imm:MaybeImm<Shift32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32ShrImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32Shr))],
        }
    },
    <l:@L> "u32rotl" <imm:MaybeImm<Shift32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32RotlImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32Rotl))],
        }
    },
    <l:@L> "u32rotr" <imm:MaybeImm<Shift32>> <r:@R> => {
        let span = span!(l, r);
        match imm {
            Some(imm) if imm == 0 => smallvec![],
            Some(imm) => smallvec![Op::Inst(Span::new(span, Instruction::U32RotrImm(imm)))],
            None => smallvec![Op::Inst(Span::new(span, Instruction::U32Rotr))],
        }
    },
}

#[inline]
InstWithU32Immediate: Instruction = {
    "mem_load" <imm:MaybeImm<U32>> => imm.map(Instruction::MemLoadImm).unwrap_or(Instruction::MemLoad),
    "mem_loadw" <imm:MaybeImm<U32>> => imm.map(Instruction::MemLoadWImm).unwrap_or(Instruction::MemLoadW),
    "mem_store" <imm:MaybeImm<U32>> => imm.map(Instruction::MemStoreImm).unwrap_or(Instruction::MemStore),
    "mem_storew" <imm:MaybeImm<U32>> => imm.map(Instruction::MemStoreWImm).unwrap_or(Instruction::MemStoreW)
}

#[inline]
InstWithLocalIndex: Instruction = {
    "locaddr" <i:Imm<U16>> => Instruction::Locaddr(i),
    "loc_load" <i:Imm<U16>> => Instruction::LocLoad(i),
    "loc_loadw" <i:Imm<U16>> => Instruction::LocLoadW(i),
    "loc_store" <i:Imm<U16>> => Instruction::LocStore(i),
    "loc_storew" <i:Imm<U16>> => Instruction::LocStoreW(i)
}

#[inline]
InstWithStackIndex: Instruction = {
    "adv_push" "." <l:@L> <i:OneBasedStackIndex> <r:@R> => Instruction::AdvPush(Immediate::Value(Span::new(span!(l, r), i))),
    "dup" <i:("." <ZeroBasedStackIndex>)?> => match i.unwrap_or(0) {
        0 => Instruction::Dup0,
        1 => Instruction::Dup1,
        2 => Instruction::Dup2,
        3 => Instruction::Dup3,
        4 => Instruction::Dup4,
        5 => Instruction::Dup5,
        6 => Instruction::Dup6,
        7 => Instruction::Dup7,
        8 => Instruction::Dup8,
        9 => Instruction::Dup9,
        10 => Instruction::Dup10,
        11 => Instruction::Dup11,
        12 => Instruction::Dup12,
        13 => Instruction::Dup13,
        14 => Instruction::Dup14,
        15 => Instruction::Dup15,
        _ => unreachable!(),
    },
    "dupw" <i:("." <ZeroBasedWordIndex>)?> => match i.unwrap_or(0) {
        0 => Instruction::DupW0,
        1 => Instruction::DupW1,
        2 => Instruction::DupW2,
        3 => Instruction::DupW3,
        _ => unreachable!(),
    },
    <l:@L> "movdn" <i:("." <ZeroBasedStackIndex>)> <r:@R> =>? Ok(match i {
        0..=1 => return Err(ParseError::User { error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 2..16 }}),
        2 => Instruction::MovDn2,
        3 => Instruction::MovDn3,
        4 => Instruction::MovDn4,
        5 => Instruction::MovDn5,
        6 => Instruction::MovDn6,
        7 => Instruction::MovDn7,
        8 => Instruction::MovDn8,
        9 => Instruction::MovDn9,
        10 => Instruction::MovDn10,
        11 => Instruction::MovDn11,
        12 => Instruction::MovDn12,
        13 => Instruction::MovDn13,
        14 => Instruction::MovDn14,
        15 => Instruction::MovDn15,
        _ => unreachable!(),
    }),
    <l:@L> "movdnw" <i:("." <ZeroBasedWordIndex>)> <r:@R> =>? Ok(match i {
        0..=1 => return Err(ParseError::User { error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 2..4 }}),
        2 => Instruction::MovDnW2,
        3 => Instruction::MovDnW3,
        _ => unreachable!(),
    }),
    <l:@L> "movup" <i:("." <ZeroBasedStackIndex>)> <r:@R> =>? Ok(match i {
        0..=1 => return Err(ParseError::User { error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 2..16 }}),
        2 => Instruction::MovUp2,
        3 => Instruction::MovUp3,
        4 => Instruction::MovUp4,
        5 => Instruction::MovUp5,
        6 => Instruction::MovUp6,
        7 => Instruction::MovUp7,
        8 => Instruction::MovUp8,
        9 => Instruction::MovUp9,
        10 => Instruction::MovUp10,
        11 => Instruction::MovUp11,
        12 => Instruction::MovUp12,
        13 => Instruction::MovUp13,
        14 => Instruction::MovUp14,
        15 => Instruction::MovUp15,
        _ => unreachable!(),
    }),
    <l:@L> "movupw" <i:("." <ZeroBasedWordIndex>)> <r:@R> =>? Ok(match i {
        0..=1 => return Err(ParseError::User { error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 2..4 }}),
        2 => Instruction::MovUpW2,
        3 => Instruction::MovUpW3,
        _ => unreachable!(),
    }),
    <l:@L> "swap" <i:("." <ZeroBasedStackIndex>)?> <r:@R> =>? Ok(match i.unwrap_or(1) {
        0 => return Err(ParseError::User { error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 1..16 }}),
        1 => Instruction::Swap1,
        2 => Instruction::Swap2,
        3 => Instruction::Swap3,
        4 => Instruction::Swap4,
        5 => Instruction::Swap5,
        6 => Instruction::Swap6,
        7 => Instruction::Swap7,
        8 => Instruction::Swap8,
        9 => Instruction::Swap9,
        10 => Instruction::Swap10,
        11 => Instruction::Swap11,
        12 => Instruction::Swap12,
        13 => Instruction::Swap13,
        14 => Instruction::Swap14,
        15 => Instruction::Swap15,
        _ => unreachable!(),
    }),
    <l:@L> "swapw" <i:("." <ZeroBasedWordIndex>)?> <r:@R> =>? Ok(match i.unwrap_or(1) {
        0 => return Err(ParseError::User { error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 1..4 }}),
        1 => Instruction::SwapW1,
        2 => Instruction::SwapW2,
        3 => Instruction::SwapW3,
        _ => unreachable!(),
    })
}

#[inline]
InstWithBitSizeImmediate: Instruction = {
    "exp.u" <imm:BitSize> => Instruction::ExpBitLength(imm)
}

Push: SmallOpsVec = {
    <l:@L> "push" "." <values:DotDelimited<IntOrHexImm>> <r:@R> =>? {
        let ops = values.into_iter().map(|imm| {
            let span = imm.span();
            Op::Inst(Span::new(span, match imm {
                Immediate::Constant(name) => Instruction::Push(Immediate::Constant(name)),
                Immediate::Value(value) => {
                    match value.into_inner() {
                        HexEncodedValue::U8(v) => Instruction::PushU8(v),
                        HexEncodedValue::U16(v) => Instruction::PushU16(v),
                        HexEncodedValue::U32(v) => Instruction::PushU32(v),
                        HexEncodedValue::Felt(v) => Instruction::PushFelt(v),
                        HexEncodedValue::Word(v) => Instruction::PushWord(v),
                    }
                }
            }))
        }).collect::<SmallOpsVec>();
        if ops.len() > 16 {
            Err(ParseError::User { error: ParsingError::PushOverflow { span: span!(l, r), count: ops.len() } })
        } else {
            Ok(ops)
        }
    }
}

// IMMEDIATES
// ================================================================================================

/// Parses an immediate integer value, either as a literal, or a reference to a constant
#[inline]
Imm<T>: Immediate<T> = {
    "." <ImmValue<T>>,
}

#[inline]
ImmValue<T>: Immediate<T> = {
    <l:@L> <t:T> <r:@R> => Immediate::Value(Span::new(span!(l, r), t)),
    <ConstantName> => Immediate::Constant(<>),
}

/// Parses an (optional) immediate integer value, either as a literal, or a reference to a constant
#[inline]
MaybeImm<T>: Option<Immediate<T>> = {
    <Imm<T>> => Some(<>),
    => None
}

/// Parses an (optional) `.<T>`
#[inline]
MaybeParam<T>: Option<T> = {
    "." <t:T> => Some(t),
    => None
}

/// Parses a valid 32-bit shift
Shift32: u8 = {
    <l:@L> <n:U8> <r:@R> =>? {
        if n > 31 {
            Err(ParseError::User { error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 0..32 } })
        } else {
            Ok(n)
        }
    }
}

U8: u8 = {
    <l:@L> <n:uint> <r:@R> =>? {
        u8::try_from(n).map_err(|error| ParseError::User {
            error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 0..(u8::MAX as usize + 1) },
        })
    }
}

U16: u16 = {
    <l:@L> <n:uint> <r:@R> =>? {
        u16::try_from(n).map_err(|error| ParseError::User {
            error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 0..(u16::MAX as usize + 1) },
        })
    }
}

U32: u32 = {
    <l:@L> <n:uint> <r:@R> =>? {
        u32::try_from(n).map_err(|error| ParseError::User {
            error: ParsingError::InvalidLiteral { span: span!(l, r), kind: LiteralErrorKind::U32Overflow },
        })
    },

    <l:@L> <value:hex_value> <r:@R> =>? {
        match value {
            HexEncodedValue::U8(v) => Ok(v as u32),
            HexEncodedValue::U16(v) => Ok(v as u32),
            HexEncodedValue::U32(v) => Ok(v),
            _ =>  Err(ParseError::User { error: ParsingError::InvalidLiteral { span: span!(l, r), kind: LiteralErrorKind::U32Overflow } }),
        }
    }
}

MastRoot: Span<RpoDigest> = {
    <l:@L> <value:hex_value> <r:@R> =>? {
        match value {
            HexEncodedValue::Word(word) => Ok(Span::new(span!(l, r), RpoDigest::from(word))),
            _ => {
                Err(ParseError::User { error: ParsingError::InvalidMastRoot { span: span!(l, r) } })
            }
        }
    }
}

ZeroBasedStackIndex: u8 = {
    <l:@L> <n:U8> <r:@R> =>? {
        if n > 15 {
            Err(ParseError::User {
                error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 0..16 },
            })
        } else {
            Ok(n)
        }
    }
}

OneBasedStackIndex: u8 = {
    <l:@L> <n:U8> <r:@R> =>? {
        if n == 0 || n > 16 {
            Err(ParseError::User {
                error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 1..17 },
            })
        } else {
            Ok(n)
        }
    }
}

StackWordOffset: u8 = {
    <l:@L> <n:U8> <r:@R> =>? {
        if n > crate::ast::MAX_STACK_WORD_OFFSET {
            Err(ParseError::User {
                error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 0..(crate::ast::MAX_STACK_WORD_OFFSET as usize + 1) },
            })
        } else {
            Ok(n)
        }
    }
}

ZeroBasedWordIndex: u8 = {
    <l:@L> <n:U8> <r:@R> =>? {
        if n > 3 {
            Err(ParseError::User {
                error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 0..4 },
            })
        } else {
            Ok(n)
        }
    }
}

OneBasedWordIndex: u8 = {
    <l:@L> <n:U8> <r:@R> =>? {
        if n == 0 || n > 4 {
            Err(ParseError::User {
                error: ParsingError::ImmediateOutOfRange { span: span!(l, r), range: 1..5 },
            })
        } else {
            Ok(n)
        }
    }
}

BitSize: u8 = {
    <l:@L> <n:U8> <r:@R> =>? {
        if n.is_power_of_two() {
            Ok(n)
        } else {
            Err(ParseError::User { error: ParsingError::InvalidLiteral { span: span!(l, r), kind: LiteralErrorKind::InvalidPowerOfTwo } })
        }
    }
}

IntOrHexImm: Immediate<HexEncodedValue> = {
    <l:@L> <value:IntOrHex> <r:@R> => Immediate::Value(Span::new(span!(l, r), value)),
    <name:ConstantName> => Immediate::Constant(<>),
}

IntOrHex: HexEncodedValue = {
    <l:@L> <n:uint> <r:@R> =>? {
        if n > Felt::MODULUS {
            return Err(ParseError::User { error: ParsingError::InvalidLiteral { span: span!(l, r), kind: LiteralErrorKind::FeltOverflow } });
        }
        if n <= (u8::MAX as u64) {
            Ok(HexEncodedValue::U8(n as u8))
        } else if n <= (u16::MAX as u64) {
            Ok(HexEncodedValue::U16(n as u16))
        } else if n <= (u32::MAX as u64) {
            Ok(HexEncodedValue::U32(n as u32))
        } else {
            Ok(HexEncodedValue::Felt(Felt::new(n)))
        }
    },

    hex_value,
}

Felt: Felt = {
    <l:@L> <n:uint> <r:@R> =>? {
        if n > Felt::MODULUS {
            return Err(ParseError::User { error: ParsingError::InvalidLiteral { span: span!(l, r), kind: LiteralErrorKind::FeltOverflow } });
        }
        Ok(Felt::new(n))
    },

    <l:@L> <value:hex_value> <r:@R> =>? {
        Ok(match value {
            HexEncodedValue::U8(v) => Felt::new(v as u64),
            HexEncodedValue::U16(v) => Felt::new(v as u64),
            HexEncodedValue::U32(v) => Felt::new(v as u64),
            HexEncodedValue::Felt(v) => v,
            HexEncodedValue::Word(_) => return Err(ParseError::User {
                error: ParsingError::InvalidHexLiteral { span: span!(l, r), kind: HexErrorKind::Overflow },
            }),
        })
    }
}

// SYMBOLS
// ================================================================================================

ProcedureName: ProcedureName = {
    BareProcedureName,
    QuotedProcedureName,
}


#[inline]
BareProcedureName: ProcedureName = {
    <BareIdent> => ProcedureName::new_unchecked(<>),
}

#[inline]
QuotedProcedureName: ProcedureName = {
    <l:@L> <name:quoted_ident> <r:@R> => {
        let name = interned.get(name).cloned().unwrap_or_else(|| {
            let name = Arc::<str>::from(name.to_string().into_boxed_str());
            interned.insert(name.clone());
            name
        });
        let id = Ident::new_unchecked(Span::new(span!(l, r), name));
        ProcedureName::new_unchecked(id)
    }
}

#[inline]
BareIdent: Ident = {
    <l:@L> <name:bare_ident> <r:@R> => {
        let name = interned.get(name).cloned().unwrap_or_else(|| {
            let name = Arc::<str>::from(name.to_string().into_boxed_str());
            interned.insert(name.clone());
            name
        });
        Ident::new_unchecked(Span::new(span!(l, r), name))
    },

    OpcodeName,
}

MaybeQualifiedName: (Ident, Option<LibraryPath>) = {
    <l:@L> <mut components:PathComponents<BareIdent>> <r:@R> =>? {
        let span = span!(l, r);
        let name = components.pop().unwrap();
        if components.is_empty() {
            Ok((name, None))
        } else {
            let mut components = VecDeque::from(components);
            let ns = components.pop_front().unwrap();
            let ns = match ns.as_str() {
                LibraryNamespace::KERNEL_PATH => LibraryNamespace::Kernel,
                LibraryNamespace::EXEC_PATH => LibraryNamespace::Exec,
                LibraryNamespace::ANON_PATH => LibraryNamespace::Anon,
                _ => LibraryNamespace::User(ns.into_inner()),
            };
            Ok((name, Some(LibraryPath::new_from_components(ns, components))))
        }
    }
}

QualifiedName: (Ident, LibraryPath) = {
    <l:@L> <first:(<BareIdent> "::")> <mut components:PathComponents<BareIdent>> <r:@R> =>? {
        let span = span!(l, r);

        let name = components.pop().unwrap();
        let ns = match first.as_str() {
            LibraryNamespace::KERNEL_PATH => LibraryNamespace::Kernel,
            LibraryNamespace::EXEC_PATH => LibraryNamespace::Exec,
            LibraryNamespace::ANON_PATH => LibraryNamespace::Anon,
            _ => LibraryNamespace::User(first.into_inner()),
        };
        Ok((name, LibraryPath::new_from_components(ns, components)))
    }
}

SignatureKind: SignatureKind = {
    "rpo_falcon512" => SignatureKind::RpoFalcon512,
}

OpcodeName: Ident = {
    <l:@L> <name:Opcode> <r:@R> => {
        let name = interned.get(name).cloned().unwrap_or_else(|| {
            let name = Arc::<str>::from(name.to_string().into_boxed_str());
            interned.insert(name.clone());
            name
        });
        Ident::new_unchecked(Span::new(span!(l, r), name))
    }
}

Opcode: &'static str = {
    "add" => "add",
    "adv_loadw" => "adv_loadw",
    "adv_pipe" => "adv_pipe",
    "adv_push" => "adv_push",
    "and" => "and",
    "assert" => "assert",
    "assertz" => "assertz",
    "assert_eq" => "assert_eq",
    "assert_eqw" => "assert_eqw",
    "begin" => "begin",
    "caller" => "caller",
    "call" => "call",
    "cdrop" => "cdrop",
    "cdropw" => "cdropw",
    "clk" => "clk",
    "const" => "const",
    "cswap" => "cswap",
    "cswapw" => "cswapw",
    "debug" => "debug",
    "div" => "div",
    "drop" => "drop",
    "dropw" => "dropw",
    "dup" => "dup",
    "dupw" => "dupw",
    "dynexec" => "dynexec",
    "dyncall" => "dyncall",
    "else" => "else",
    "emit" => "emit",
    "end" => "end",
    "eq" => "eq",
    "eqw" => "eqw",
    "ext2add" => "ext2add",
    "ext2div" => "ext2div",
    "ext2inv" => "ext2inv",
    "ext2mul" => "ext2mul",
    "ext2neg" => "ext2neg",
    "ext2sub" => "ext2sub",
    "err" => "err",
    "exec" => "exec",
    "exp" => "exp",
    "export" => "export",
    "gt" => "gt",
    "gte" => "gte",
    "hash" => "hash",
    "hperm" => "hperm",
    "hmerge" => "hmerge",
    "ilog2" => "ilog2",
    "inv" => "inv",
    "is_odd" => "is_odd",
    "local" => "local",
    "locaddr" => "locaddr",
    "loc_load" => "loc_load",
    "loc_loadw" => "loc_loadw",
    "loc_store" => "loc_store",
    "loc_storew" => "loc_storew",
    "lt" => "lt",
    "lte" => "lte",
    "mem" => "mem",
    "mem_load" => "mem_load",
    "mem_loadw" => "mem_loadw",
    "mem_store" => "mem_store",
    "mem_storew" => "mem_storew",
    "mem_stream" => "mem_stream",
    "movdn" => "movdn",
    "movdnw" => "movdnw",
    "movup" => "movup",
    "movupw" => "movupw",
    "mtree_get" => "mtree_get",
    "mtree_merge" => "mtree_merge",
    "mtree_set" => "mtree_set",
    "mtree_verify" => "mtree_verify",
    "mul" => "mul",
    "neg" => "neg",
    "neq" => "neq",
    "not" => "not",
    "or" => "or",
    "padw" => "padw",
    "pow2" => "pow2",
    "proc" => "proc",
    "procref" => "procref",
    "push" => "push",
    "repeat" => "repeat",
    "rpo_falcon512" => "rpo_falcon512",
    "sdepth" => "sdepth",
    "stack" => "stack",
    "sub" => "sub",
    "swap" => "swap",
    "swapw" => "swapw",
    "swapdw" => "swapdw",
    "syscall" => "syscall",
    "trace" => "trace",
    "u32and" => "u32and",
    "u32assert" => "u32assert",
    "u32assert2" => "u32assert2",
    "u32assertw" => "u32assertw",
    "u32cast" => "u32cast",
    "u32div" => "u32div",
    "u32divmod" => "u32divmod",
    "u32gt" => "u32gt",
    "u32gte" => "u32gte",
    "u32lt" => "u32lt",
    "u32lte" => "u32lte",
    "u32max" => "u32max",
    "u32min" => "u32min",
    "u32mod" => "u32mod",
    "u32not" => "u32not",
    "u32or" => "u32or",
    "u32overflowing_add" => "u32overflowing_add",
    "u32overflowing_add3" => "u32overflowing_add3",
    "u32overflowing_madd" => "u32overflowing_madd",
    "u32overflowing_mul" => "u32overflowing_mul",
    "u32overflowing_sub" => "u32overflowing_sub",
    "u32popcnt" => "u32popcnt",
    "u32clz" => "u32clz",
    "u32ctz" => "u32ctz",
    "u32clo" => "u32clo",
    "u32cto" => "u32cto",
    "u32rotl" => "u32rotl",
    "u32rotr" => "u32rotr",
    "u32shl" => "u32shl",
    "u32shr" => "u32shr",
    "u32split" => "u32split",
    "u32test" => "u32test",
    "u32testw" => "u32testw",
    "u32wrapping_add" => "u32wrapping_add",
    "u32wrapping_add3" => "u32wrapping_add3",
    "u32wrapping_madd" => "u32wrapping_madd",
    "u32wrapping_mul" => "u32wrapping_mul",
    "u32wrapping_sub" => "u32wrapping_sub",
    "u32xor" => "u32xor",
    "xor" => "xor",
}

// CONSTANT EXPRESSIONS
// ================================================================================================

ConstantExpr: ConstantExpr = {
    <l:@L> <x:ConstantExpr> "+" <y:ConstantExpr100> <r:@R> =>? {
        let expr = ConstantExpr::BinaryOp {  span: span!(l, r), op: ConstantOp::Add, lhs: Box::new(x), rhs: Box::new(y) };
        expr.try_fold().map_err(|error| ParseError::User { error })
    },

    <l:@L> <x:ConstantExpr> "-" <y:ConstantExpr100> <r:@R> =>? {
        let expr = ConstantExpr::BinaryOp { span: span!(l, r), op: ConstantOp::Sub, lhs: Box::new(x), rhs: Box::new(y) };
        expr.try_fold().map_err(|error| ParseError::User { error })
    },

    ConstantExpr100,
}

ConstantExpr100: ConstantExpr = {
    <l:@L> <x:ConstantExpr100> "*" <y:Term> <r:@R> =>? {
        let expr = ConstantExpr::BinaryOp { span: span!(l, r), op: ConstantOp::Mul, lhs: Box::new(x), rhs: Box::new(y) };
        expr.try_fold().map_err(|error| ParseError::User { error })
    },

    <l:@L> <x:ConstantExpr100> "/" <y:Term> <r:@R> =>? {
        let expr = ConstantExpr::BinaryOp { span: span!(l, r), op: ConstantOp::Div, lhs: Box::new(x), rhs: Box::new(y) };
        expr.try_fold().map_err(|error| ParseError::User { error })
    },

    <l:@L> <x:ConstantExpr100> "//" <y:Term> <r:@R> =>? {
        let expr = ConstantExpr::BinaryOp { span: span!(l, r), op: ConstantOp::IntDiv, lhs: Box::new(x), rhs: Box::new(y) };
        expr.try_fold().map_err(|error| ParseError::User { error })
    },

    Term
}

#[inline]
ConstantName: Ident = {
    <l:@L> <name:const_ident> <r:@R> => {
        let name = interned.get(name).cloned().unwrap_or_else(|| {
            let name = Arc::<str>::from(name.to_string().into_boxed_str());
            interned.insert(name.clone());
            name
        });
        Ident::new_unchecked(Span::new(span!(l, r), name))
    }
}

Term: ConstantExpr = {
    "(" <ConstantExpr> ")",

    <value:ImmValue<Felt>> => {
        match value {
            Immediate::Value(value) => ConstantExpr::Literal(value),
            Immediate::Constant(name) => ConstantExpr::Var(name),
        }
    }
}
