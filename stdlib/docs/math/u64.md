
## std::math::u64
| Procedure | Description |
| ----------- | ------------- |
| overflowing_add | Performs addition of two unsigned 64 bit integers preserving the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [overflowing_flag, c_hi, c_lo, ...], where c = (a + b) % 2^64<br />This takes 6 cycles.<br /> |
| wrapping_add | Performs addition of two unsigned 64 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a + b) % 2^64<br />This takes 7 cycles.<br /> |
| wrapping_sub | Performs subtraction of two unsigned 64 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a - b) % 2^64<br />This takes 10 cycles.<br /> |
| overflowing_sub | Performs subtraction of two unsigned 64 bit integers preserving the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [underflowing_flag, c_hi, c_lo, ...], where c = (a - b) % 2^64<br />This takes 11 cycles.<br /> |
| wrapping_mul | Performs multiplication of two unsigned 64 bit integers discarding the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a * b) % 2^64<br />This takes 11 cycles.<br /> |
| overflowing_mul | Performs multiplication of two unsigned 64 bit integers preserving the overflow.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_mid_hi, c_mid_lo, c_lo, ...], where c = (a * b) % 2^64<br />This takes 18 cycles.<br /> |
| lt | Performs less-than comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a < b, and 0 otherwise.<br />This takes 11 cycles.<br /> |
| gt | Performs greater-than comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a > b, and 0 otherwise.<br />This takes 11 cycles.<br /> |
| lte | Performs less-than-or-equal comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a <= b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| gte | Performs greater-than-or-equal comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a >= b, and 0 otherwise.<br />This takes 12 cycles.<br /> |
| eq | Performs equality comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise.<br />This takes 6 cycles.<br /> |
| neq | Performs inequality comparison of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a != b, and 0 otherwise.<br />This takes 6 cycles.<br /> |
| eqz | Performs comparison to zero of an unsigned 64 bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == 0, and 0 otherwise.<br />This takes 4 cycles.<br /> |
| min | Compares two unsigned 64 bit integers and drop the larger one from the stack.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a when a < b, and b otherwise.<br />This takes 23 cycles.<br /> |
| max | Compares two unsigned 64 bit integers and drop the smaller one from the stack.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a when a > b, and b otherwise.<br />This takes 23 cycles.<br /> |
| div | Performs division of two unsigned 64 bit integers discarding the remainder.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a // b<br />This takes 54 cycles.<br /> |
| mod | Performs modulo operation of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a % b<br />This takes 54 cycles.<br /> |
| divmod | Performs divmod operation of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [r_hi, r_lo, q_hi, q_lo ...], where r = a % b, q = a / b<br />This takes 54 cycles.<br /> |
| and | Performs bitwise AND of two unsigned 64-bit integers.<br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a AND b.<br />This takes 6 cycles.<br /> |
| or | Performs bitwise OR of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a OR b.<br />This takes 16 cycles.<br /> |
| xor | Performs bitwise XOR of two unsigned 64 bit integers.<br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br />Stack transition looks as follows:<br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a XOR b.<br />This takes 6 cycles.<br /> |
| shl | Performs left shift of one unsigned 64-bit integer using the pow2 operation.<br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br />The shift value should be in the range [0, 64), otherwise it will result in an<br />error.<br />Stack transition looks as follows:<br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a << b mod 2^64.<br />This takes 28 cycles.<br /> |
| shr | Performs right shift of one unsigned 64-bit integer using the pow2 operation.<br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br />The shift value should be in the range [0, 64), otherwise it will result in an<br />error.<br />Stack transition looks as follows:<br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a >> b.<br />This takes 44 cycles.<br /> |
| rotl | Performs left rotation of one unsigned 64-bit integer using the pow2 operation.<br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br />The shift value should be in the range [0, 64), otherwise it will result in an<br />error.<br />Stack transition looks as follows:<br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a << b mod 2^64.<br />This takes 35 cycles.<br /> |
| rotr | Performs right rotation of one unsigned 64-bit integer using the pow2 operation.<br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br />The shift value should be in the range [0, 64), otherwise it will result in an<br />error.<br />Stack transition looks as follows:<br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a << b mod 2^64.<br />This takes 40 cycles.<br /> |
| clz | Counts the number of leading zeros of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [clz, ...], where clz is a number of leading zeros of value n.<br />This takes 43 cycles.<br /> |
| ctz | Counts the number of trailing zeros of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [ctz, ...], where ctz is a number of trailing zeros of value n.<br />This takes 41 cycles.<br /> |
| clo | Counts the number of leading ones of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [clo, ...], where clo is a number of leading ones of value n.<br />This takes 42 cycles.<br /> |
| cto | Counts the number of trailing ones of one unsigned 64-bit integer.<br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br />Stack transition looks as follows:<br />[n_hi, n_lo, ...] -> [cto, ...], where cto is a number of trailing ones of value n.<br />This takes 40 cycles.<br /> |
