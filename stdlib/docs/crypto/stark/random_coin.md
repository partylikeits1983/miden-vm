
## std::crypto::stark::random_coin
| Procedure | Description |
| ----------- | ------------- |
| add_two_words | Helper procedure to compute addition of two words component-wise.<br />Input: [b3, b2, b1, b0, a3, a2, a1, a0]<br />Output: [c3, c2, c1, c0]<br /><br />Cycles: 16<br /> |
| get_rate_1 | Return the first half of the rate portion of the random coin state<br /><br />The random coin uses RPO to generate data. The RPO state is composed of 3<br />words, 2 words for the rate, and 1 word for the capacity. This procedure<br />returns the first word of the RPO state.<br /><br />Input: [...]<br />Output: [R1, ...]<br />Cycles: 6<br /> |
| get_rate_2 | Return the second half of the rate portion of the random coin state<br /><br />The random coin uses RPO to generate data. The RPO state is composed of 3<br />words, 2 words for the rate, and 1 word for the capacity. This procedure<br />returns the first word of the RPO state.<br /><br />Input: [...]<br />Output: [R2, ...]<br />Cycles: 6<br /> |
| get_capacity | Return the capacity portion of the random coin state<br /><br />The random coin uses RPO to generate data. The RPO state is composed of 3<br />words, 2 words for the rate, and 1 word for the capacity. This procedure<br />returns the first word of the RPO state.<br /><br />Input: [...]<br />Output: [C, ...]<br />Cycles: 6<br /> |
| init_seed | Initializes the seed for randomness generation by computing the hash of the proof context using<br />the trace length, number of queries, logarithm of blowup factor and the number of bits of<br />grinding. Currently, this part, as well as the rest of the STARK verifier assumes a blowup factor<br />equal to 8.<br />The ouput of this procedure is the capacity portion of the state after applying `hperm`.<br /><br />Input: [log(trace_length), num_queries, blowup, grinding, ...]<br />Output: [C]<br />Cycles: 175<br /> |
| reseed | Reseed the random coin with `DATA`<br /><br />Input: [DATA, ...]<br />Ouput: [...]<br />Cycles: 54<br /> |
| generate_random_coefficients | Generates a `num_tuples` tuples of random field elements and stores them in memory<br />starting from address `dest_ptr`. Each memory address holds two tuples.<br />TODO: Generalize by keeping track of something similar to the `output` variable in `RpoRandomCoin`<br />so that we keep track of already used randomness and know when there is a need to apply `hperm`.<br /><br />Input: [dest_ptr, num_tuples, ...]<br />Output: [...]<br /><br />Cycles: 69 + (22 * num_tuples) / 4<br /> |
| generate_random_coefficients_pad | Generates a `num_tuples` tuples of random field elements and stores them in memory<br />starting from address `dest_ptr`. Each memory address holds one tuple.<br />TODO: Generalize by keeping track of something similar to the `output` variable in `RpoRandomCoin`<br />so that we keep track of already used randomness and know when there is a need to apply `hperm`.<br /><br />Input: [dest_ptr, num_tuples, ...]<br />Output: [...]<br /><br />Cycles: 104 + (69 * num_tuples) / 4<br /> |
| generate_aux_randomness | Draw a list of random extension field elements related to the auxiliary trace and store the list<br />in memory from `aux_rand_elem_ptr` to `aux_rand_elem_ptr + 8 - 1`<br /><br />Input: [aux_rand_elem_ptr, ...]<br />Output: [...]<br />Cycles: 150<br /> |
| generate_constraint_composition_coefficients | Draw constraint composition random coefficients and save them into memory in the region from<br />`compos_coef_ptr` `compos_coef_ptr + 118 - 1` as `(r1_1, r1_0, r0_1, r0_0)`<br /><br />Input: [compos_coef_ptr, ...]<br />Output: [...]<br />Cycles: 1309<br /> |
| generate_deep_composition_random_coefficients | Draw deep composition polynomial random coefficients and save them into memory in the region from<br />`deep_rand_coef_ptr` to `deep_rand_coef_ptr + 89 - 1` as `(0, 0, r0_1, r0_0)`<br />The number of coefficients is equal to:<br />1. (72 + 9) * 2 Felt for the main and auxiliary traces.<br />2. 8 * 2 Felt for constraint polynomial.<br />Total: 89 tuples of type (Felt, Felt)<br /><br />Input: [deep_rand_coef_ptr, ...]<br />Output: [...]<br />Cycles: 1693<br /> |
| generate_z_zN | Generate the OOD challenge point `z = (z0, z1)` and compute `z^N` where N is<br />the trace length. The resulting word `[(z_1, z_0)^N, z1, z0]` is stored in the<br />global memory address `exec.z_ptr` reservedfor it.<br /><br />Input: [X, ...]<br />Output: [...]<br />Note: The top word on the stack is consumed by this procedure.<br />Cycles: 21 + 10 * log(N)<br /> |
| generate_list_indices | Generate a list of `num_queries` number of random indices in the range<br />[0, lde_size] and store it in memory starting from `query_ptr`.<br />The list is stored as `(r, depth, y, y)` where `depth` is `log(lde_domain_size)`.<br />`depth` is needed when computing the deep queries.<br />TODO: the case of duplicate queries<br /><br />Input: [query_ptr, num_queries, ...]<br />Output: [...]<br /><br />Cycles: 267 + q * 236 + r * 29 where q = num_queries / 8 and r = num_queries % 8<br /><br />NOTE: This procedure is called first, and right after the PoW check, thus the first element<br />in the rate portion of the state is discarded.<br />NOTE: The cycles count can be estimated, using the fact that r < 8, via the more compact formula<br />470 + 236 * (num_queries / 8)<br /> |
| check_pow | Check that the Proof-of-Work contained in the nonce is equal to the required number<br />of bits prescribed by grinding bits. The grinding factor is assumed to be less than 32.<br /><br />Input: [grinding_factor, ...]<br />Output: [...]<br />Cycles: 73<br /> |
