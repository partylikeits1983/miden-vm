Initializes four memory addresses, provided for storing initial 4x4 blake3<br />state matrix ( i.e. 16 elements each of 32 -bit ), for computing blake3 2-to-1 hash<br /><br />Expected stack state:<br /><br />[state_0_3_addr, state_4_7_addr, state_8_11_addr, state_12_15_addr]<br /><br />Note, state_`i`_`j`_addr -> absolute address of {state[i], state[i+1], state[i+2], state[i+3]} in memory | j = i+3<br /><br />Final stack state:<br /><br />[...]<br /><br />Initialized stack state is written back to provided memory addresses.<br /><br />Functionally this routine is equivalent to https://github.com/itzmeanjan/blake3/blob/f07d32e/include/blake3.hpp#!L1709-L1713<br />
## std::crypto::hashes::blake3
| Procedure | Description |
| ----------- | ------------- |
| initialize_1to1 | Initializes four memory addresses, provided for storing initial 4x4 blake3<br />state matrix ( i.e. 16 elements each of 32 -bit ), for computing blake3 1-to-1 hash<br /><br />Expected stack state:<br /><br />[state_0_3_addr, state_4_7_addr, state_8_11_addr, state_12_15_addr]<br /><br />Note, state_`i`_`j`_addr -> absolute address of {state[i], state[i+1], state[i+2], state[i+3]} in memory \| j = i+3<br /><br />Final stack state:<br /><br />[...]<br /><br />Initialized stack state is written back to provided memory addresses.<br /><br />Functionally this routine is equivalent to https://github.com/itzmeanjan/blake3/blob/f07d32e/include/blake3.hpp#!L1709-L1713<br />with only difference being value of BLOCK_LEN = 32<br /> |
| permute_msg_words | Permutes ordered message words, kept on stack top ( = sixteen 32 -bit BLAKE3 words )<br /><br />Expected stack top:<br /><br />[s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15]<br /><br />After permutation, stack top:<br /><br />[s2, s6, s3, s10, s7, s0, s4, s13, s1, s11, s12, s5, s9, s14, s15, s8]<br /><br />See https://github.com/itzmeanjan/blake3/blob/f07d32ec10cbc8a10663b7e6539e0b1dab3e453b/include/blake3.hpp#!L1623-L1639<br />and https://github.com/0xPolygonMiden/miden-vm/pull/313#!discussion_r922627984<br /> |
| finalize | Given blake3 state matrix on stack top ( in order ) as 16 elements ( each of 32 -bit ),<br />this routine computes output chaining value i.e. 2-to-1 hashing digest.<br /><br />Expected stack state:<br /><br />[state0, state1, state2, state3, state4, state5, state6, state7, state8, state9, state10, state11, state12, state13, state14, state15]<br /><br />After finalizing, stack should look like<br /><br />[dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7]<br /><br />See https://github.com/BLAKE3-team/BLAKE3/blob/da4c792/reference_impl/reference_impl.rs#!L116-L119 ,<br />you'll notice I've skipped executing second statement in loop body of above hyperlinked implementation,<br />that's because it doesn't dictate what output of 2-to-1 hash will be.<br /> |
| columnar_mixing | Given blake3 state matrix ( total 16 elements, each of 32 -bit ) and<br />8 message words ( each of 32 -bit ), this routine performs column-wise mixing<br />of message words into blake3 hash state.<br /><br />Functionality wise this routine is equivalent to https://github.com/BLAKE3-team/BLAKE3/blob/da4c792/reference_impl/reference_impl.rs#!L55-L59<br /><br />Expected stack state:<br /><br />[state0_3_addr, state4_7_addr, state8_11_addr, state12_15_addr, m0, m1, m2, m3, m4, m5, m6, m7]<br /><br />Note, state_`i`_`j`_addr -> absolute address of {state[i], state[i+1], state[i+2], state[i+3]} in memory \| j = i+3<br /><br />Meaning four consecutive blake3 state words can be read from memory easily.<br /><br />Final stack state:<br /><br />[state0, state1, state2, state3, state4, state5, state6, state7, state8, state9, state10, state11, state12, state13, state14, state15]<br /><br />i.e. whole blake3 state is placed on stack ( in order ).<br /> |
| diagonal_mixing | Given blake3 state matrix ( total 16 elements, each of 32 -bit ) and<br />8 message words ( each of 32 -bit ), this routine performs diagonal-wise mixing<br />of message words into blake3 hash state.<br /><br />Functionality wise this routine is equivalent to https://github.com/BLAKE3-team/BLAKE3/blob/da4c792/reference_impl/reference_impl.rs#!L61-L64<br /><br />Expected stack state:<br /><br />[state0_3_addr, state4_7_addr, state8_11_addr, state12_15_addr, m0, m1, m2, m3, m4, m5, m6, m7]<br /><br />Note, state_`i`_`j`_addr -> absolute address of {state[i], state[i+1], state[i+2], state[i+3]} in memory \| j = i+3<br /><br />Meaning four consecutive blake3 state words can be read from memory easily.<br /><br />Final stack state:<br /><br />[state0, state1, state2, state3, state4, state5, state6, state7, state8, state9, state10, state11, state12, state13, state14, state15]<br /><br />i.e. whole blake3 state is placed on stack ( in order ).<br /> |
| round | Given blake3 state matrix ( total 16 elements, each of 32 -bit ) and<br />16 message words ( each of 32 -bit ), this routine applies single round of mixing<br />of message words into hash state i.e. msg_word[0..8] are mixed into hash state using<br />columnar mixing while remaining message words ( msg_word[8..16] ) are mixed into hash state<br />using diagonal mixing.<br /><br />Functionality wise this routine is equivalent to https://github.com/BLAKE3-team/BLAKE3/blob/da4c792/reference_impl/reference_impl.rs#!L54-L65<br /><br />Expected stack state:<br /><br />[state0_3_addr, state4_7_addr, state8_11_addr, state12_15_addr, m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15]<br /><br />Note, state_`i`_`j`_addr -> absolute address of {state[i], state[i+1], state[i+2], state[i+3]} in memory \| j = i+3<br /><br />Meaning four consecutive blake3 state words can be read from memory easily.<br /><br />Final stack state:<br /><br />[...]<br /><br />i.e. mixed state matrix lives in memory addresses {state0_3_addr, state4_7_addr, state8_11_addr, state12_15_addr},<br />which were provided, on stack top, while invoking this routine.<br /> |
| compress | Given blake3 state matrix ( total 16 elements, each of 32 -bit ) and a message block<br />i.e. 16 message words ( each of 32 -bit ), this routine applies 7 rounds of mixing<br />of (permuted) message words into hash state.<br /><br />Functionality wise this routine is equivalent to https://github.com/BLAKE3-team/BLAKE3/blob/da4c792/reference_impl/reference_impl.rs#!L75-L114<br /><br />Expected stack state:<br /><br />[state0_3_addr, state4_7_addr, state8_11_addr, state12_15_addr, m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15]<br /><br />Note, state_`i`_`j`_addr -> absolute address of {state[i], state[i+1], state[i+2], state[i+3]} in memory \| j = i+3<br /><br />Meaning four consecutive blake3 state words can be read from memory easily.<br /><br />Final stack state:<br /><br />[...]<br /><br />i.e. 7 -round mixed state matrix lives in memory addresses {state0_3_addr, state4_7_addr, state8_11_addr, state12_15_addr},<br />which were provided, on stack top, while invoking this routine. So updated state matrix can be read by caller routine, by reading<br />the content of memory addresses where state was provided as routine input.<br /> |
| hash_2to1 | Blake3 2-to-1 hash function, which takes 64 -bytes input and produces 32 -bytes output digest<br /><br />Expected stack state:<br /><br />[msg0, msg1, msg2, msg3, msg4, msg5, msg6, msg7, msg8, msg9, msg10, msg11, msg12, msg13, msg14, msg15, ...]<br /><br />msg`i` -> 32 -bit message word \| i ∈ [0, 16)<br /><br />Final stack state:<br /><br />[dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /><br />dig`i` -> 32 -bit digest word \| i ∈ [0, 8)<br /> |
| hash_1to1 | Blake3 1-to-1 hash function, which takes 32 -bytes input and produces 32 -bytes output digest<br /><br />Expected stack state:<br /><br />[msg0, msg1, msg2, msg3, msg4, msg5, msg6, msg7, ...]<br /><br />msg`i` -> 32 -bit message word \| i ∈ [0, 8)<br /><br />Final stack state:<br /><br />[dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /><br />dig`i` -> 32 -bit digest word \| i ∈ [0, 8)<br /> |
