Computes SHA2 small sigma 0.<br /><br />Input: [x, ...]<br />Output: [y, ...]<br /><br />Where y = σ_0(x), as defined in SHA specification<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L73-L79<br />
## std::crypto::hashes::sha256
| Procedure | Description |
| ----------- | ------------- |
| small_sigma_1 | Computes SHA2 small sigma 1.<br /><br />Input: [x, ...]<br />Output: [y, ...]<br /><br />Where y = σ_1(x), as defined in SHA specification<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L81-L87<br /> |
| cap_sigma_0 | Computes SHA2 big sigma 0.<br /><br />Input: [x, ...]<br />Output: [y, ...]<br /><br />Where y = Σ_0(x), as defined in SHA specification<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L57-L63<br /> |
| cap_sigma_1 | Computes SHA2 big sigma 1.<br /><br />Input: [x, ...]<br />Output: [y, ...]<br /><br />Where y = Σ_1(x), as defined in SHA specification<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L65-L71<br /> |
| ch | Computes SHA2 ch.<br /><br />Input: [x, y, z, ...]<br />Output: [o, ...]<br /><br />Where o = ch(x, y, z), as defined in SHA specification<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L37-L45<br /> |
| maj | Computes SHA2 maj.<br /><br />Input: [x, y, z, ...]<br />Output: [o, ...]<br /><br />Where o = maj(x, y, z), as defined in SHA specification<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L47-L55<br /> |
| rev_element_order | Reverses order of first four elements on stack<br /><br />Input: [a, b, c, d, ...]<br />Output: [d, c, b, a, ...]<br />Cycles: 3<br /> |
| compute_message_schedule_word | Computes next message schedule word<br /><br />Input: [a, b, c, d, ...]<br />Output: [r, ...]<br /><br />Where:<br />If to be computed message schedule word has index i ∈ [16, 64), then<br />a, b, c, d will have following indices in message schedule<br /><br />a = msg[i - 2]<br />b = msg[i - 7]<br />c = msg[i - 15]<br />d = msg[i - 16]<br /><br />t0 = small_sigma_1(a) + b<br />t1 = small_sigma_0(c) + d<br />r = t0 + t1<br /> |
| consume_message_word | Consumes constant and message word into hash state according to SHA256 specification.<br /><br />Input: [a, b, c, d, e, f, g, h, CONST_i, WORD_i]<br />Output: [a', b', c', d', e', f', g', h']<br /><br />Where:<br />- i ∈ [0, 64)<br />- a through h are working variables of SHA256 ( i.e. hash state )<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2_256.hpp#L165-L175<br /> |
| prepare_message_schedule_and_consume | Computes whole message schedule of 64 message words and consumes them into hash state.<br /><br />Input: [state0, state1, state2, state3, state4, state5, state6, state7, msg0, msg1, msg2, msg3, msg4, msg5, msg6, msg7, msg8, msg9, msg10, msg11, msg12, msg13, msg14, msg15]<br />Output: [state0', state1', state2', state3', state4', state5', state6', state7']<br /><br />Where:<br />- state0 through state7 are the hash state (in terms of 8 SHA256 words)<br />- msg0 through msg15 are the 64 -bytes input message (in terms of 16 SHA256 words)<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L89-L113<br />& https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2_256.hpp#L148-L187 ( loop body execution )<br /> |
| consume_padding_message_schedule | Consumes precomputed message schedule of padding bytes into hash state, returns final hash state.<br /><br />Input: [state0, state1, state2, state3, state4, state5, state6, state7, ...]<br />Output: [state0', state1', state2', state3', state4', state5', state6', state7']<br /><br />Note, in SHA256 2-to-1 hashing, 64 -bytes are padded, which is processed as second message<br />block ( each SHA256 message block is 64 -bytes wide ). That message block is used for generating<br />message schedule of 64 SHA256 words. That's exactly what can be precomputed & is consumed here<br />( in this routine ) into provided hash state.<br /><br />Note, each SHA256 word is 32 -bit wide<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2_256.hpp#L148-L187 ( loop<br />body execution when i = 1 i.e. consuming padding bytes )<br /> |
| hash_2to1 | Given 64 -bytes input, this routine computes 32 -bytes SHA256 digest<br /><br />Input: [m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15, ...]<br />Output: [dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /><br />Where: m[0,16) = 32 -bit word<br /><br />Note, each SHA256 word is 32 -bit wide, so that's how input is expected.<br />As you've 64 -bytes, consider packing 4 consecutive bytes into single word,<br />maintaining big endian byte order.<br /><br />SHA256 digest is represented in terms of eight 32 -bit words ( big endian byte order ).<br /> |
| hash_1to1 | Given 32 -bytes input, this routine computes 32 -bytes SHA256 digest<br /><br />Expected stack state:<br /><br />Input: [m0, m1, m2, m3, m4, m5, m6, m7, ...]<br />Output: [dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /><br />Where: m[0,8) = 32 -bit word<br /><br />Note, each SHA256 word is 32 -bit wide, so that's how input is expected.<br />As you've 32 -bytes, consider packing 4 consecutive bytes into single word,<br />maintaining big endian byte order.<br /><br />SHA256 digest is represented in terms of eight 32 -bit words ( big endian byte order ).<br /> |
| hash_memory | Given a memory address and a message length in bytes, compute its sha256 digest<br /><br />- There must be space for writing the padding after the message in memory<br />- The padding space after the message must be all zeros before this procedure is called<br /><br />Input:  [addr, len, ...]<br />Output: [dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /> |
