Computes SHA2 small sigma 0.<br /><br />Input: [x, ...]<br />Output: [y, ...]<br /><br />Where y = Ïƒ_0(x), as defined in SHA specification<br />See https://github.com/itzmeanjan/merklize-sha/blob/8a2c006/include/sha2.hpp#L73-L79<br />
## std::crypto::hashes::sha256
| Procedure | Description |
| ----------- | ------------- |
| hash_2to1 | Given 64 -bytes input, this routine computes 32 -bytes SHA256 digest<br /><br />Input: [m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15, ...]<br />Output: [dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /><br />Where: m[0,16) = 32 -bit word<br /><br />Note, each SHA256 word is 32 -bit wide, so that's how input is expected.<br />As you've 64 -bytes, consider packing 4 consecutive bytes into single word,<br />maintaining big endian byte order.<br /><br />SHA256 digest is represented in terms of eight 32 -bit words ( big endian byte order ).<br /> |
| hash_1to1 | Given 32 -bytes input, this routine computes 32 -bytes SHA256 digest<br /><br />Expected stack state:<br /><br />Input: [m0, m1, m2, m3, m4, m5, m6, m7, ...]<br />Output: [dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /><br />Where: m[0,8) = 32 -bit word<br /><br />Note, each SHA256 word is 32 -bit wide, so that's how input is expected.<br />As you've 32 -bytes, consider packing 4 consecutive bytes into single word,<br />maintaining big endian byte order.<br /><br />SHA256 digest is represented in terms of eight 32 -bit words ( big endian byte order ).<br /> |
| hash_memory | Given a memory address and a message length in bytes, compute its sha256 digest<br /><br />- There must be space for writing the padding after the message in memory<br />- The padding space after the message must be all zeros before this procedure is called<br /><br />Input:  [addr, len, ...]<br />Output: [dig0, dig1, dig2, dig3, dig4, dig5, dig6, dig7, ...]<br /> |
