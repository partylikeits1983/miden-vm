Keccak-p[1600, 24] permutation's θ step mapping function, which is implemented<br />in terms of 32 -bit word size ( bit interleaved representation )<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L55-L98 for original implementation<br /><br />Expected stack state :<br /><br />[state_addr, ...]<br /><br />Final stack state :<br /><br />[ ... ]<br /><br />Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses<br />s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.<br /><br />Consecutive memory addresses can be computed by repeated application of `add.1`.<br />
## std::crypto::hashes::keccak256
| Procedure | Description |
| ----------- | ------------- |
| rho | Keccak-p[1600, 24] permutation's ρ step mapping function, which is implemented<br />in terms of 32 -bit word size ( bit interleaved representation )<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L115-L147 for original implementation<br /><br />Expected stack state :<br /><br />[state_addr, ...]<br /><br />Final stack state :<br /><br />[ ... ]<br /><br />Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses<br />s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.<br /><br />Consecutive memory addresses can be computed by repeated application of `add.1`.<br /> |
| pi | Keccak-p[1600, 24] permutation's π step mapping function, which is implemented<br />in terms of 32 -bit word size ( bit interleaved representation )<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L169-L207 for original implementation<br /><br />Expected stack state :<br /><br />[state_addr, ...]<br /><br />Final stack state :<br /><br />[ ... ]<br /><br />Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses<br />s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.<br /><br />Consecutive memory addresses can be computed by repeated application of `add.1`.<br /> |
| chi | Keccak-p[1600, 24] permutation's χ step mapping function, which is implemented<br />in terms of 32 -bit word size ( bit interleaved representation )<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L233-L271 for original implementation<br /><br />Expected stack state :<br /><br />[state_addr, ...]<br /><br />Final stack state :<br /><br />[ ... ]<br /><br />Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses<br />s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.<br /><br />Consecutive memory addresses can be computed by repeated application of `add.1`.<br /> |
| iota | Keccak-p[1600, 24] permutation's ι ( iota ) function, which is<br />implemented in terms of 32 -bit word size ( bit interleaved form );<br />imagine https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L288-L306<br />invoked with (c0, c1) as template arguments<br /><br />Expected stack state :<br /><br />[state_addr, c0, c1, ...]<br /><br />Final stack state :<br /><br />[ ... ]<br /><br />All this routine does is<br /><br />state[0] ^= c0<br />state[1] ^= c1<br /> |
| round | Keccak-p[1600, 24] permutation round, without `iota` function ( all other<br />functions i.e. `theta`, `rho`, `pi`, `chi` are applied in order )<br /><br />As `iota` function involves xoring constant factors with first lane of state array<br />( read state[0, 0] ), it's required to invoke them seperately after completion of<br />this procedure's execution.<br /><br />Expected stack state :<br /><br />[start_addr, ... ]<br /><br />After finishing execution, stack looks like<br /><br />[ ... ]<br /><br />Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses<br />s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.<br /><br />Consecutive memory addresses can be computed by repeated application of `add.1`.<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L325-L340<br /> |
| keccak_p | Keccak-p[1600, 24] permutation, applying 24 rounds on state array of size  5 x 5 x 64,<br />where each 64 -bit lane is represented in bit interleaved form ( in terms of two 32 -bit words ).<br /><br />Expected stack state :<br /><br />[start_addr, ... ]<br /><br />After finishing execution, stack looks like<br /><br />[ ... ]<br /><br />Whole keccak-p[1600, 24] state can be represented using fifty u32 elements i.e. 13 absolute memory addresses<br />s.t. last two elements of 12 -th ( when indexed from zero ) memory address are zeroed.<br /><br />Consecutive memory addresses can be computed by repeated application of `add.1`.<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/sha3.hpp#L379-L427<br /> |
| to_bit_interleaved | Given two 32 -bit unsigned integers ( standard form ), representing upper and lower<br />bits of a 64 -bit unsigned integer ( actually a keccak-[1600, 24] lane ),<br />this function converts them into bit interleaved representation, where two 32 -bit<br />unsigned integers ( even portion & then odd portion ) hold bits in even and odd<br />indices of 64 -bit unsigned integer ( remember it's represented in terms of<br />two 32 -bit elements )<br /><br />Input stack state :<br /><br />[hi, lo, ...]<br /><br />After application of bit interleaving, stack looks like<br /><br />[even, odd, ...]<br /><br />Read more about bit interleaved representation in section 2.1 of https://keccak.team/files/Keccak-implementation-3.2.pdf<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/utils.hpp#L123-L149<br />for reference implementation in higher level language.<br /> |
| from_bit_interleaved | Given two 32 -bit unsigned integers ( in bit interleaved form ), representing even and odd<br />positioned bits of a 64 -bit unsigned integer ( actually a keccak-[1600, 24] lane ),<br />this function converts them into standard representation, where two 32 -bit<br />unsigned integers hold higher ( 32 -bit ) and lower ( 32 -bit ) bits of standard<br />representation of 64 -bit unsigned integer<br /><br />Input stack state :<br /><br />[even, odd, ...]<br /><br />After application of logic, stack looks like<br /><br />[hi, lo, ...]<br /><br />This function reverts the action done by `to_bit_interleaved` function implemented above.<br /><br />Read more about bit interleaved representation in section 2.1 of https://keccak.team/files/Keccak-implementation-3.2.pdf<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/utils.hpp#L151-L175<br />for reference implementation in higher level language.<br /> |
| to_state_array | Given 64 -bytes input ( in terms of sixteen u32 elements on stack top ) to 2-to-1<br />keccak256 hash function, this function prepares 5 x 5 x 64 keccak-p[1600, 24] state<br />bit array such that each of twenty five 64 -bit wide lane is represented in bit<br />interleaved form, using two 32 -bit integers. After completion of execution of<br />this function, state array should live in allocated memory ( total fifty u32 elements, stored in<br />13 consecutive memory addresses s.t. starting absolute address is provided ).<br /><br />Input stack state :<br /><br />[state_addr, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, ...]<br /><br />Note, state_addr is the starting absolute memory address where keccak-p[1600, 24] state<br />is kept. Consecutive addresses can be computed by repeated application of `add.1` instruction.<br /><br />Final stack state :<br /><br />[...]<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/keccak_256.hpp#L73-L153<br /> |
| to_digest | Given 32 -bytes digest ( in terms of eight u32 elements on stack top ) in bit interleaved form,<br />this function attempts to convert those into standard representation, where eight u32 elements<br />live on stack top, each pair of them hold higher and lower bits of 64 -bit unsigned<br />integer ( lane of keccak-p[1600, 24] state array )<br /><br />Input stack state :<br /><br />[lane0_even, lane0_odd, lane1_even, lane1_odd, lane2_even, lane2_odd, lane3_even, lane3_odd, ...]<br /><br />Output stack state :<br /><br />[dig0_hi, dig0_lo, dig1_hi, dig1_lo, dig2_hi, dig2_lo, dig3_hi, dig3_lo, ...]<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/keccak_256.hpp#L180-L209<br /> |
| hash | Given 64 -bytes input, in terms of sixteen 32 -bit unsigned integers, where each pair<br />of them holding higher & lower 32 -bits of 64 -bit unsigned integer ( reinterpreted on<br />host CPU from little endian byte array ) respectively, this function computes 32 -bytes<br />keccak256 digest, held on stack top, represented in terms of eight 32 -bit unsigned integers,<br />where each pair of them keeps higher and lower 32 -bits of 64 -bit unsigned integer respectively<br /><br />Expected stack state :<br /><br />[iword0, iword1, iword2, iword3, iword4, iword5, iword6, iword7,<br />iword8, iword9, iword10, iword11, iword12, iword13, iword14, iword15, ... ]<br /><br />Final stack state :<br /><br />[oword0, oword1, oword2, oword3, oword4, oword5, oword6, oword7, ... ]<br /><br />See https://github.com/itzmeanjan/merklize-sha/blob/1d35aae9da7fed20127489f362b4bc93242a516c/include/keccak_256.hpp#L232-L257<br /> |
